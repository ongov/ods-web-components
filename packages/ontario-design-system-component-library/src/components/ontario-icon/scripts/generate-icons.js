/**
 * With `ontario-design-system-component-library` being your active directory, run the `npm run generate:icons` command in your terminal.
 *
 * This script is used to generate the individual icon component files (`ontario-icon-*.tsx`).
 * The components are generated by reading and parsing each icon's SVG file into a JSON object using `svgson`, a 3rd party module.
 * The parsed JSON object is then consumed to generate each icon component by using a pre-defined template.
 * This approach follows the DRY (don't repeat yourself) concept and reduces the maintenance effort for the icon components.
 */

const fs = require('fs');
const path = require('path');
const { parseSync, stringify } = require('svgson');

const iconDirectory = './node_modules/@ontario-digital-service/ontario-design-system-global-styles/dist/icons';
const iconsWithoutColour = [
	'ontario-icon-alert-error',
	'ontario-icon-alert-information',
	'ontario-icon-alert-success',
	'ontario-icon-alert-warning',
	'ontario-icon-dropdown-arrow',
	'ontario-icon-interac-en',
	'ontario-icon-interac-fr',
	'ontario-icon-interac-en-alt',
	'ontario-icon-interac-fr-alt',
	'ontario-icon-mastercard',
	'ontario-icon-mastercard-alt',
	'ontario-icon-visa',
];

/**
 * Transform name of icon to remove the `ontario-icon-` prefix
 * @param {*} iconName name of icon
 * @returns name of icon without the `ontario-icon-` prefix
 */
const getId = iconName => {
	return iconName.startsWith('ontario-icon-') ? iconName.replace('ontario-icon-', '') : iconName;
};

/**
 * Transform a string into Pascal case
 * @param {*} string a string to be operated on
 * @returns a string in Pascal case
 */
const toPascalCase = string => string.replace(/\w+/g, w => w[0].toUpperCase() + w.slice(1).toLowerCase()).replaceAll('-', '');

/**
 * Generate the icon component template
 * @param {*} svgObject svg content in JSON object notation
 * @param {*} iconName name of the icon
 * @returns template to be used to create the icon component (`.tsx`) files
 */
const getIconComponentTemplate = (svgObject, iconName) => {
	let svgElement = stringify(svgObject);
	return `// content automatically generated by \`generate-icons.js\` begins
import { Component, Prop, h, Watch } from '@stencil/core';
    
@Component({
    tag: '${iconName}',
    styleUrl: 'ontario-icon.scss',
    shadow: true,
})
export class ${toPascalCase(iconName)} {
    /**
     * The icon width will autogenerate the height since the icons are in square format, thus preserving
     * the aspect ratio.
     */
    @Prop() iconWidth: number = 24;
    ${svgObject.hasColour ? `
    /**
     * Set the icon's colour.
     * Note that some icon's colour cannot be changed.
     */
    @Prop() colour: "black" | "blue" | "grey" = "black";
    ` : ``}
    @Watch('iconWidth')
    validateWidth() {
        const defaultWidth = 24;
            
        // If value is not a number, set the iconWidth to be 24
        if (isNaN(this.iconWidth)) {
            this.iconWidth = defaultWidth;
        }
    }

    componentWillLoad() {
        this.validateWidth();
    }

    render() {
        return (
            <div class=${svgObject.hasColour ? `{\`ontario-icon ontario-icon--\${this.colour}\`}` : `"ontario-icon"`} style={{ 'width': \`\${this.iconWidth}px\` }}>
                ${svgElement}
            </div>
        );
    }
};
// content automatically generated by \`generate-icons.js\` ends
`;
};

/**
 * Create an icon component for each icon presented in the `iconDirectory`
 */
const createIconComponents = () => { 
    fs.readdir(iconDirectory, (err, iconFiles) => {
        if (err) throw err;

        // traverse through each filename
        iconFiles?.forEach(iconFilename => {

            // proceed with icon generation process if the file extension is `.svg` and the filename starts with the string `ontario-icon-`.
            if (iconFilename.includes('.svg') && iconFilename.startsWith('ontario-icon-')) {

                // Strip the path data and file extension from `iconFilename` and store the resulting value in `iconName`
                const iconName = path.basename(iconFilename, '.svg');

                // the array.slice() function is used to remove the `./` from the `iconDirectory` variable
                const iconPath = path.join(__dirname, `../../../../${iconDirectory.slice(2)}/${iconFilename}`);

                // read the SVG file
                fs.readFile(iconPath, { encoding: 'utf-8' }, (err, svgContent) => {
                    if (err) throw err;

                    // parse `svgContent` into JSON object.
                    let svgObject = parseSync(svgContent, {
                        transformNode: node => {
                            // transform `node` object to rename `viewbox` property to `viewBox` for HTML consumption.
                            if (node.attributes["viewbox"] && !node.attributes["viewBox"]) {
                                Object.defineProperty(node.attributes, 'viewBox', Object.getOwnPropertyDescriptor(node.attributes, 'viewbox'));
                                delete node.attributes['viewbox'];
                            };

                            // transform `node` object to add a `hasColour` property to the main object.
                            node.hasColour = !iconsWithoutColour.includes(iconName);

                            // transform `node` object to add an `id` attribute to the parent `<svg>`.
                            node.attributes.id = getId(iconName);
                            return node;
                        },
                    });

                    // generate the template
                    let iconComponentTemplate = getIconComponentTemplate(svgObject, iconName);

                    // create `ontario-icon-*.tsx` file
                    fs.writeFile(`./src/components/ontario-icon/${iconName}.tsx`, iconComponentTemplate, (err) => {
                        if (err) throw err;
                    });
                });
            }
        });
    });
};

createIconComponents();
