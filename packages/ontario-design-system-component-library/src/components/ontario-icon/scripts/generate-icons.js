/**
 * With `ontario-design-system-component-library` being your active directory, run the `npm run generate:icons` command in your terminal.
 *
 * This script is used to generate the individual icon component files (`ontario-icon-*.tsx`).
 * The components are generated by reading and parsing each icon's SVG file into a JSON object using `svgson`, a 3rd party module.
 * The parsed JSON object is then consumed to generate each icon component by using a pre-defined template.
 * This approach follows the DRY (don't repeat yourself) concept and reduces the maintenance effort for the icon components.
 */

const {readdir, readFile, writeFile} = require('fs/promises');
const path = require('path');
const { parse, stringify } = require('svgson');

const iconDirectory = './node_modules/@ontario-digital-service/ontario-design-system-global-styles/dist/icons';
const iconNamePrefix = 'ontario-icon-';
const iconsWithoutColour = [
	`${iconNamePrefix}alert-error`,
	`${iconNamePrefix}alert-information`,
	`${iconNamePrefix}alert-success`,
	`${iconNamePrefix}alert-warning`,
	`${iconNamePrefix}dropdown-arrow`,
	`${iconNamePrefix}interac-en`,
	`${iconNamePrefix}interac-fr`,
	`${iconNamePrefix}interac-en-alt`,
	`${iconNamePrefix}interac-fr-alt`,
	`${iconNamePrefix}mastercard`,
	`${iconNamePrefix}mastercard-alt`,
    `${iconNamePrefix}visa`,
];

/**
 * Transform name of icon to remove the `ontario-icon-` prefix
 * @param {*} iconName name of icon
 * @returns name of icon without the `ontario-icon-` prefix
 */
const getId = iconName => {
	return iconName.startsWith(iconNamePrefix) ? iconName.replace(iconNamePrefix, '') : iconName;
};

/**
 * Transform a string into Pascal case
 * @param {*} string a string to be operated on
 * @returns a string in Pascal case
 */
const toPascalCase = string => string.replace(/\w+/g, w => w[0].toUpperCase() + w.slice(1).toLowerCase()).replaceAll('-', '');

/**
 * Generate the icon component template
 * @param {*} svgObject svg content in JSON object notation
 * @param {*} iconName name of the icon
 * @returns template to be used to create the icon component (`.tsx`) files
 */
const getIconComponentTemplate = (svgObject, iconName) => {
	const svgElement = stringify(svgObject);
	return `// content automatically generated by \`generate-icons.js\` begins
import { Component, Prop, h, Watch } from '@stencil/core';
import { Icon } from './icon.interface';
${svgObject.hasColour ? `import { IconColour } from './ontario-icon.enum';
` : `` }
@Component({
    tag: '${iconName}',
    styleUrl: 'ontario-icon.scss',
    shadow: true,
})
export class ${toPascalCase(iconName)} implements Icon {
    /**
     * The icon width will autogenerate the height since the icons are in square format, thus preserving
     * the aspect ratio.
     */
    @Prop() iconWidth: number = 24;
    ${svgObject.hasColour ? `
    /**
     * Set the icon's colour.
     * Some icon's colour cannot be changed.
     * Note that the \`keyof typeof\` syntax is not necessary to use the enum as a type with StencilJS component.
     */
    @Prop() colour: IconColour = IconColour.black;

    /**
     * Watch for changes in the \`colour\` variable for validation purpose.
     * If the user input doesn't match one of the enum values then \`colour\` will be set to its default (\`black\`).
     * If a match is found in one of the enum values then \`colour\` will be set to the matching enum value.
     */
    @Watch('colour')
    validateColour() {
        this.colour = (this.colour && Object.values(IconColour).find(colour => colour === this.colour.toLowerCase())) || IconColour.black;
    }
    ` : ``}
    /**
     * Watch for changes in the \`iconWidth\` variable for validation purpose.
     * If the user input is not a number or is a negative number then \`iconWidth\` will be set to its default (24).
     */
    @Watch('iconWidth')
    validateWidth() {
        const defaultWidth = 24;

        if (isNaN(this.iconWidth) || (!isNaN(this.iconWidth) && this.iconWidth <= 0)) {
            this.iconWidth = defaultWidth;
        }
    }

	/**
	 * Stencil component lifecycle method that is called once after the component is first connected to the DOM.
	 */
    componentWillLoad() {${svgObject.hasColour ? `
        this.validateColour();` : ``}
        this.validateWidth();
    }

    /**
	 * Returns the HTML code to be rendered into a custom element.
	 */
    render() {
        return (
            <div class=${svgObject.hasColour ? `{\`ontario-icon ontario-icon--\${this.colour}\`}` : `'ontario-icon'`} style={{ 'width': \`\${this.iconWidth}px\` }}>
                ${svgElement}
            </div>
        );
    }
};
// content automatically generated by \`generate-icons.js\` ends
`;
};

/**
 * Create an icon component for each icon presented in the `iconDirectory`
 */
const createIconComponents = async () => {
    const iconFiles = await readdir(iconDirectory);
    
    for (const iconFile of iconFiles) {

        // proceed with icon generation process if the file extension is `.svg` and the filename starts with the string `ontario-icon-`.
        if (iconFile.includes('.svg') && iconFile.startsWith(iconNamePrefix)) {

            // strip the path data and file extension from `iconFilename` and store the resulting value in `iconName`
            const iconName = path.basename(iconFile, '.svg');

            // the array.slice() function is used to remove the `./` from the `iconDirectory` variable
            // NodeJS's `readFile` resolves path relative to the current working directory and hence absolute path is used to ensure everyone can execute this script.
            // a environment variable `__dirname` is used to retrieve the absolute path to the folder containing this script.
            // because the icons are stored in the node_modules, the `../../../../` is required to traverse up to the node_modules folder for `path.join` to create an absolute path to the icons folder.
            const iconFilePath = path.join(__dirname, `../../../../${iconDirectory.slice(2)}/${iconFile}`);
            const iconFileContent = await readFile(iconFilePath, {encoding: 'utf-8'});
            const iconObject = await parse(iconFileContent, {
                transformNode: node => {
                    // transform `node` object to rename `viewbox` property to `viewBox` for HTML consumption.
                    if (node.attributes['viewbox'] && !node.attributes['viewBox']) {
                        Object.defineProperty(node.attributes, 'viewBox', Object.getOwnPropertyDescriptor(node.attributes, 'viewbox'));
                        delete node.attributes['viewbox'];
                    };

                    // transform `node` object to add a `hasColour` property to the main object.
                    node.hasColour = !iconsWithoutColour.includes(iconName);

                    // transform `node` object to add an `id` attribute to the parent `<svg>`.
                    node.attributes.id = getId(iconName);
                    return node;
                },
            });

            // generate the template
            const iconComponentTemplate = getIconComponentTemplate(iconObject, iconName);

            // create `ontario-icon-*.tsx` file
            await writeFile(`./src/components/ontario-icon/${iconName}.tsx`, iconComponentTemplate);
        }
    }
};

createIconComponents();
